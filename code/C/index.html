<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="liluan">
  <link rel="canonical" href="https://mkdocs.zimoapps.com/code/C/">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>C/C++ - LiLuan's Blog</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "C/C++";
    var mkdocs_page_input_path = "code\\C.md";
    var mkdocs_page_url = "/code/C/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> LiLuan's Blog</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">主页</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../MyPC/">我的笔记</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">文本编辑</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../text/MkDocs/">MkDocks用法指南</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../text/MarkDown/">MarkDown用法指南</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../text/LatexNote/">LaTeX用法指南</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">编程</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">C/C++</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">基本操作</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">变量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">判断</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_5">循环</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">指针</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#int">指针类型（int *）的存储过程和原理</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_7">结构体</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_8">常用函数</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Python/">Python</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../java/">Java</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">社会</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../skill/god/">周易</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">关于</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../about/release-notes/">发行说明</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../about/contributing/">贡献</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../about/license/">许可</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">LiLuan's Blog</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>编程 &raquo;</li>
        
      
    
    <li>C/C++</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <pre><code class="language-c++">//  这是我的第一个C语言代码
#include &lt;stdio.h&gt;
int main()  //  这是主函数
{
    printf(&quot;Hello World\n&quot;);    //  写第一行字Hello World
    printf(&quot;Welcome to CPL World\n&quot;);   //  写第二行字Welcome to CPL World
    return 0;   //  主函数返回值
}
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<h1 id="_1">语法</h1>
<h2 id="_2">基本操作</h2>
<p>main function</p>
<pre><code class="language-c++">int main()  //  这是主函数
{
    return 0;   //  主函数返回值
}
</code></pre>
<h3 id="_3">变量</h3>
<p>基本类型：int, short, long, signed, unsigned, char, float, double, void. 
控制：if...else, switch...case...default, for, while, do...while, return, break, continue, goto. </p>
<p>自定义类型：enum, struct, union, typedef. </p>
<p>修饰词：const, static, extern, inline, restrict, volatile. </p>
<p>运算符：+, -, *, /, %, ++, --, &amp;, |, ~, ^, &amp;&amp;, ||, !, &lt;, &gt;, &lt;=, &gt;=, ==, !=, &lt;&lt;, &gt;&gt;, ., -&gt;, ?:, sizeof. </p>
<p>复合运算符 </p>
<p>预处理器：#include, #define, #undef,#if/#ifdef/#ifndef...#elif...#else...#endif, defined, #pragma,#error </p>
<p>有极少数关键字有多种语义，例如static、void，算是麻烦一点。还有指针相关的类型和使用也算是比较麻烦点。其他都没有太复杂的东西。看着床头上832页、两寸厚的《C++ Templates》第二版，几乎只涉及几个C++关键字（template, typename, decltype, using），然后就会觉得上面的都太简单了。</p>
<p>变量</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>关键字</th>
<th>占用字节</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>整型</td>
<td>int</td>
<td>4 byte</td>
<td>-65537~65537</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>短</td>
<td>short</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>长</td>
<td>long</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>有符号</td>
<td>signed</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>无符号</td>
<td>unsigned</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>空</td>
<td>void</td>
<td>byte</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<h3 id="_4">判断</h3>
<pre><code class="language-c++">if () 
{

}
</code></pre>
<pre><code class="language-c++">if () 
{

} else {

}
</code></pre>
<pre><code class="language-c++">if ()
{

} else if () {

} else {

}
</code></pre>
<h3 id="_5">循环</h3>
<pre><code class="language-c++">for (int i; i &lt; N; i++) 
{
    printf(&quot;%d &quot;, i);
}
</code></pre>
<pre><code class="language-c++">while(i &lt; N)
{
    printf(&quot;%d &quot;, i);
    i++;
}
</code></pre>
<pre><code class="language-c++">do {
    printf(&quot;%d &quot;, i);
    i++;
} while(i &lt; N)
</code></pre>
<h2 id="_6">指针</h2>
<h3 id="int">指针类型（int *）的存储过程和原理</h3>
<p>3.1 指针类型的赋值规范</p>
<p>（1）第一种先定义后赋值</p>
<pre><code class="language-c++">int *p;
p = &amp;a; // 变量p存放的a的地址
printf(&quot;p = %d\n&quot;,p); // p = 6618636
</code></pre>
<p>重点：先了解，指针类型，<code>int *p</code>,虽然是<code>*p</code>在一起写着，但是变量名叫<code>p</code>，类型为<code>int *</code>，也就是整型的指针类型，当你理清变量名和类型之后，你对指针的理解程度已经懂了大半了 。</p>
<p>（2）第二种定义赋值一步完成</p>
<pre><code class="language-c++">int *r = &amp;a; // 存放的是a的地址
printf(&quot;r = %d\n&quot;,r); // p = 6618636
</code></pre>
<p>还有一种常用的错误赋值方法：<code>p = a;</code>。错误的操作，不能把一个具体的数字赋给指针（类型不匹配），一个指针类型，一个int类型</p>
<p>可以把存放一个int类型变量的地址赋给一个int <em>指针类型的变量。
'='左边是一个int </em>指针类型的变量 ，可以存放放置着int类型数值的地址。
'='右边是&amp;a，a是int类型的变量数值5，&amp;是取地址符，&amp;a就是拿到int类型a的数值的地址。</p>
<p>总的来说，就是把a的那片空间，给了p一个钥匙，让p也可以对a的那片空间操作，这个已经属于指针操作了，后面我们会讲到。</p>
<p>由上述可以证明，c语言的赋值，必须是类型对应</p>
<p>总结：int <em>p; 变量名叫p，类型为int </em>,可存放一个int数据的地址 。
注意：这块的可存放一个int数据的地址，不是存放一个地址，是int类型</p>
<p>例如：</p>
<pre><code class="language-c++">int a = 5;
int *p;
p = &amp;a;
</code></pre>
<p>这里a是一个int类型的变量，存放的int类型的数值5，&amp;a 取到了存放int类型a的地址。</p>
<p><code>p = &amp;a;</code> 把int类型a的地址赋给了int <em>类型的p，即就是int </em>类型的变量可存放一个int数据的地址。</p>
<pre><code class="language-c++">int *p; //
int **q; //
int ***m; //
</code></pre>
<h2 id="_7">结构体</h2>
<p>结构体的声明语法如下</p>
<pre><code class="language-c++">struct [structure tag] /*结构体的标签*/{

   member definition; /*零个或多个成员变量的定义*/
   member definition;
   ...
   member definition;
} [one or more structure variables];  /*一个或多个结构体变量的定义*/
</code></pre>
<p>结构体标签(structure tag)是可选的，但是推荐还是写上，这样使得代码更加规范清晰，成员变量的定义一般为基本数据类型，如 int age; char name[10]等，成员变量之间使用;隔开,最后一个成员变量后面的;可选, </p>
<p>如下面定义一个图书信息的结构体变量</p>
<pre><code class="language-c++">struct Books {
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
</code></pre>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct Books {
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};

int main( ) {

   struct Books Book1; /* Declare Book1 of type Book */
   struct Books Book2; /* Declare Book2 of type Book */

   /* book 1 specification */
   strcpy( Book1.title, &quot;C Programming&quot;);
   strcpy( Book1.author, &quot;Nuha Ali&quot;);
   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);
   Book1.book_id = 6495407;

   /* book 2 specification */
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Zara Ali&quot;);
   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);
   Book2.book_id = 6495700;

   /* print Book1 info */
   printf( &quot;Book 1 title : %s\n&quot;, Book1.title);
   printf( &quot;Book 1 author : %s\n&quot;, Book1.author);
   printf( &quot;Book 1 subject : %s\n&quot;, Book1.subject);
   printf( &quot;Book 1 book_id : %d\n&quot;, Book1.book_id);

   /* print Book2 info */
   printf( &quot;Book 2 title : %s\n&quot;, Book2.title);
   printf( &quot;Book 2 author : %s\n&quot;, Book2.author);
   printf( &quot;Book 2 subject : %s\n&quot;, Book2.subject);
   printf( &quot;Book 2 book_id : %d\n&quot;, Book2.book_id);

   return 0;
}
// 输出以下结果
/* 
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
*/
</code></pre>
<pre><code class="language-c++">
</code></pre>
<p>结构体指针</p>
<p>结构体数组</p>
<p>结构体的内存计算</p>
<h2 id="_8">常用函数</h2>
<h1 id="_9">数据结构</h1>
<h1 id="_10">算法</h1>
<h2 id="sort">Sort</h2>
<p><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
交换排序（冒泡排序、快速排序）、插入排序（简单插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、归并排序（二路归并排序、多路归并排序）。</p>
<p><strong>非比较排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。
计数排序、桶排序、基数排序。</p>
<pre><code class="language-c++">void SelectSort(int arr[], int n)
{
    /*  int k;      //指向最小元素下标
        for (int i = 0; i &lt; n - 1; i++)
        {
            k = i;  //初始指向0，每次排序后i加一
            for (int j = i + 1; j &lt; n; j++)
            {
                if (arr[k]&gt;arr[j])
                {
                    k = j;  //将最小元素下标赋值给k
                }
            }
            swap(arr, k, i);
        }
    */
    for (int i = 0; i &lt; n - 1; i++)
    {
        for (int j = i + 1; j &lt; n; j++)
        {
            if (arr[i] &gt; arr[j])
            {
                swap(arr, i, j);
            }
        }
    }
}
</code></pre>
<pre><code class="language-c++">void swap(int arr[], int x, int y)
{
    int temp = arr[x];
    arr[x] = arr[y];
    arr[y] = temp;
}
</code></pre>
<pre><code class="language-c++">void show(int arr[], int n)
{
    for (int i = 0; i &lt; n; i++)
    {
        printf(&quot;%d\t&quot;, arr[i]);
    }
    printf(&quot;\n&quot;);
}
</code></pre>
<pre><code class="language-c++">void _merge_in_arr(int arr[], int left, int mid, int right)
{
    int length = right - left + 1;                  //定义一个辅助的空间的长度
    int *pData = (int*)malloc(sizeof(int)*length);//分配一个动态内存来调整元素的位置
    memset(pData, 0, sizeof(int)* length);

    //合并
    int low = left;     //左边区间的起始下标
    int hig = mid + 1;  //右边区间的起始下标
    int index = 0;      //辅助数组的下标

    while (hig &lt;= right)//右区间没有合并完
    {
        while (low &lt;= mid &amp;&amp; arr[low] &lt;= arr[hig])//证明左区间没有合并完，且左区间的值小于右区间的值
        {
            pData[index] = arr[low];            //把左边的值放进辅助数组
            low++;                              //左边往高位移，下一次需要判断左边的新下标
            index++;                            //下一次放进辅助数组的新下标
        }
        if (low &gt; mid)  //证明左区间已经放完
            break;

        while (hig &lt;= right &amp;&amp; arr[low] &gt; arr[hig])//证明右区间没有合并完，且左区间的值大于右区间的值
        {
            pData[index] = arr[hig];            //把右边的值放进辅助数组
            hig++;                              //右边往高位移，下一次需要判断右边的新下标
            index++;                            //下一次放进辅助数组的新下标
        }
    }

    //到这一步，证明起码有一个区间已经合并完成
    if (hig &lt;= right)   //证明右边没有完成
        memmove(&amp;pData[index], &amp;arr[hig], sizeof(int)* (right - hig + 1));
    if (low &lt;= mid)     //证明左边没有完成
        memmove(&amp;pData[index], &amp;arr[low], sizeof(int)* (mid - low + 1));

    //把所有区间都合并到了辅助区间
    memmove(&amp;arr[left], pData, sizeof(int)* length);
    free(pData);    //释放空间
}

void radix_sort(int arr[], size_t len)
{
    int**temp = (int **)malloc(sizeof(int) * 10);   //10行
    //申请动态内存   辅助数组temp[10][];
    for (int i = 0; i &lt; 10; i++)
    {
        temp[i] = (int *)malloc(sizeof(int)*len);
    }

    for (int i = 1; i &lt;= 100; i *= 10)//循环数值可能有的位数
    {
        for (int x = 0; x &lt; 10; ++x)//辅助数组行循环
        {
            for (int y = 0; y &lt; len; ++y)//辅助数组列循环
            {
                temp[x][y] = -1;//辅助数组的初始化赋值，-1表示在arr里面不可能出现的数值 
            }
        }
        //arr数组中的元素放入辅助数组
        for (int m = 0; m &lt; len; ++m)
        {
            int index = (arr[m] / i) % 10;
            temp[index][m] = arr[m];
        }
        //把辅助数组的内容放回待排序数组
        int k = 0;//待排序的下标
        for (int x = 0; x &lt; 10; x++)
        {
            for (int y = 0; y &lt; len; ++y)
            {
                if (temp[x][y] != -1)
                    arr[k++] = temp[x][y];
            }
        }
    }
    //释放内存
    for (int i = 0; i &lt; 10; i++)
    {
        free(temp[i]);
    }
    free(temp);
}
</code></pre>
<pre><code class="language-c++">void MergeSort(int arr[], int left, int right)
{
    if (left &gt;= right)//递归的终止条件，left == right证明这个区间只有一个元素，不需要再拆了
        return;
    int mid = ((right - left) &gt;&gt; 1) + left;//求中点
    MergeSort(arr, left, mid);      //拆分左
    MergeSort(arr, mid + 1, right); //拆分右
    //并操作
    _merge_in_arr(arr, left, mid, right);
}
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">void QuickSort(int arr[], int left, int right)
{
    if (left &gt;= right) return;//只有一个元素不排
    int i = left, j = right;
    while (i &lt; j)
    {
        while (i &lt; j&amp;&amp;arr[j] &gt;= arr[left])  //从右向左找第一个小于arr[left]的数
            --j;
        while (i &lt; j&amp;&amp;arr[i] &lt; arr[left])   //从左向右找第一个大于等于arr[left]的数
            ++i;
        if (i &lt; j)
            swap(arr, i, j);
    }
    QuickSort(arr, left, i - 1);//排左边
    QuickSort(arr, i + 1, right);//排右边
}
</code></pre>
<pre><code class="language-c++">void ShellSort(int arr[], int n)
{
    int tempVal, j;
    int jump = n &gt;&gt; 2;          //步长值
    while (jump != 0)
    {
        for (int i = jump; i &lt; n; i++)
        {
            tempVal = arr[i];   //保存待排序的第一个数，也就是待插入的数
            for (j = i - jump; j &gt;= 0 &amp;&amp; tempVal &lt; arr[j]; j -= jump)
            {
                arr[j + jump] = arr[j];
            }
            arr[j + jump] = tempVal;
        }
        jump = jump &gt;&gt; 1;       //步长值减半
    }
}
</code></pre>
<pre><code class="language-c++">void InsertSort(int arr[], int n)
{
    int tempVal;
    for (int i = 1, j; i &lt; n; i++)
    {
        tempVal = arr[i];   //保存要插入的值
        for (j = i - 1; tempVal &lt; arr[j] &amp;&amp; j &gt;= 0; --j)    //数据往后移动，给要插入的值腾位
        {
            arr[j + 1] = arr[j];
        }
        arr[j + 1] = tempVal;   //插入数据
    }
}
</code></pre>
<pre><code class="language-c++">void BubbleSort(int arr[], int n)
{
    //从小到大排序 相邻来两个数比较，将大的数字往后放
    for (int i = 0; i &lt; n - 1; i++)         //n-1是因为数组下标最大为n-1 要进行10轮比较
    {
        //n-1是因为数组下标最大为n-1 要进行10次比较，再减i是因为每最后的i个元素已经有序不需要继续排序
        for (int j = 0; j &lt; n - 1 - i; j++)
        {
            if (arr[j] &gt; arr[j + 1])            //两两比较，将小的数据放前面
            {
                swap(arr, j + 1, j);
            }
        }
    }
}
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<h2 id="search">Search</h2>
<ol>
<li>顺序查找</li>
<li>二分查找</li>
<li>插值查找</li>
<li>斐波那契查找</li>
<li>分块查找</li>
<li>树表查找</li>
<li>哈希查找</li>
</ol>
<p>顺序查找
基本思想：顺序查找也称为线形查找，属于无序查找算法。</p>
<pre><code class="language-c++">int length = arr.Length;
            for (int i = 0; i &lt; length; i++)
            {
                if(arr[i] == value)
                {
                    return i;
                }
            }
            return -1;
</code></pre>
<p>二分查找
基本思想：元素必须是有序的，属于有序查找算法。注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》</p>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<h1 id="_11">例程</h1>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
<pre><code class="language-c++">
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../Python/" class="btn btn-neutral float-right" title="Python">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../../text/LatexNote/" class="btn btn-neutral" title="LaTeX用法指南"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Copyright &copy; 2014 <a href="https://twitter.com/_tomchristie">Tom Christie</a>, Maintained by the <a href="/about/release-notes/#maintenance-team">MkDocs Team</a>. <a href="http://www.beian.miit.gov.cn" target="_blank">蜀ICP备19036239号</a></p>
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/zimocode/mkdocs-docs-zh/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../../text/LatexNote/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../Python/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
